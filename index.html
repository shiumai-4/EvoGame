<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvoGame</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            background-color: #121212;
            color: #eeeeee;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #81c784;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
        }
        #gameBoard {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(7, 50px);
            gap: 5px;
            margin-bottom: 1rem;
            border: 2px solid #424242;
            padding: 5px;
            border-radius: 5px;
            background-color: #212121;
        }
        .square {
            width: 50px;
            height: 50px;
            border: 1px solid #616161;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            background-color: #303030;
            color: #eeeeee;
            position: relative;
            line-height: 1.1;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
        }
        .square.empty {
            background-color: #303030;
        }
        .square.wall {
            background-color: #757575;
            color: #eeeeee;
        }
        .enemy-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .enemy {
            background-color: #ef5350;
            color: #ffffff;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            position: absolute;
            z-index: 2;
        }
        .square.ally {
            background-color: #42a5f5;
            color: #ffffff;
        }
        .square.max-level-ally {
            background-color: #0d47a1;
            color: #ffffff;
        }
        .square.new-ally {
            color: #0d7f48;
            background-color: #fffde7;
            animation: new-ally-fade-in 0.3s ease-out forwards;
            border: 2px solid #faef8c;
        }
        .square.top-right-indicator::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: yellow;
        }
        #mainButtonContainer {
            margin-bottom: 1.2rem;
            text-align: center;
        }
        #controlArea {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.2rem;
        }
        #levelDisplay {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.8rem;
            color: #ffffff;
            text-align: center;
            margin-bottom: 0.5rem;
        }
        #levelDisplay .level-value {
            font-weight: bold;
        }
        #controlButton {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 15px;
            background-color: #12e3c8;
            color: #0c034e;
            border: none;
            transition: background-color 0.3s ease;
            width: 10rem;
            text-align: center;
        }
        #controlButton:hover {
            background-color: #29f8dc;
        }
        #autoButton, #speedButton, #autoStopButton {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            transition: background-color 0.3s ease;
            height: 40px;
        }
        #autoButton {
            background-color: #424242;
            color: #eeeeee;
        }
        #autoButton:hover {
            background-color: #616161;
        }
        #autoButton.active {
            background-color: #ffb74d;
            color: #121212;
        }
        #speedButton {
            background-color: #826509;
            color: #ffffff;
        }
        #speedButton:hover {
            background-color: #b58e0d;
        }
        #autoStopButton {
            display: grid;
            grid-template-columns: repeat(3, 8px);
            grid-template-rows: repeat(3, 8px);
            gap: 2px;
            padding: 7px;
            background-color: #424242;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .stop-cell {
            width: 8px;
            height: 8px;
        }
        #autoStopButton.state-unstop .stop-cell { background-color: rgb(178, 178, 178); }
        #autoStopButton.state-unstop .stop-cell:nth-child(5) { background-color: #42a5f5; }
        #autoStopButton.state-around .stop-cell { background-color: #ef5350; }
        #autoStopButton.state-around .stop-cell:nth-child(5) { background-color: #42a5f5; }
        #autoStopButton.state-adjacent .stop-cell { background-color: rgb(178, 178, 178); }
        #autoStopButton.state-adjacent .stop-cell:nth-child(2),
        #autoStopButton.state-adjacent .stop-cell:nth-child(4),
        #autoStopButton.state-adjacent .stop-cell:nth-child(6),
        #autoStopButton.state-adjacent .stop-cell:nth-child(8) { background-color: #ef5350; }
        #autoStopButton.state-adjacent .stop-cell:nth-child(5) { background-color: #42a5f5; }

        #specialActionsArea {
            display: flex;
            gap: 20px;
            margin-bottom: 0.5rem;
            align-items: center;
        }
        .special-action {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        #specialActionsArea button {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            background-color: #6a1b9a;
            color: #ffffff;
            border: none;
            transition: background-color 0.3s ease;
            font-family: 'Press Start 2P', cursive;
        }
        #specialActionsArea button:hover:not(:disabled) {
            background-color: #8e24aa;
        }
        #specialActionsArea button:disabled {
            background-color: #4a4a4a;
            cursor: not-allowed;
            color: #888888;
        }
        #specialActionsArea button#bonusButton.active {
            background-color: #42a5f5;
        }
        .counter-span {
            font-size: 0.8rem;
            color: #ffd700;
            font-family: 'Press Start 2P', cursive;
        }
        #gameOverPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            border-radius: 5px;
            display: none;
            z-index: 5;
        }
        #gameOverPanel h2 {
            color: #ef5350;
        }
        #gameOverPanel button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            background-color: #ef5350;
            color: #ffffff;
            border: none;
            transition: background-color 0.3s ease;
            font-family: 'Press Start 2P', cursive;
        }
        #gameOverPanel button:hover {
            background-color: #c62828;
        }
        .game-controls button {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            background-color: #424242;
            color: #eeeeee;
            border: none;
            transition: background-color 0.3s ease;
        }
        .game-controls button:hover {
             background-color: #616161;
        }
        #resetGameButton {
            background-color: #39255b;
        }
        #resetGameButton:hover {
            background-color: #322548;
        }
        #finishButton {
            display: none; /* 初期状態では非表示 */
            background-color: #b71c1c;
            color: #ffffff;
        }
        #finishButton:hover:not(:disabled) {
            background-color: #c62828;
        }
        #finishButton:disabled {
            background-color: #4a4a4a;
            cursor: not-allowed;
            color: #888888;
        }

        #infoMessageBox,#messageBox {
            background-color: #1d1c20;
            border: 1px solid #424242;
            border-radius: 5px;
            padding: 3px;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            overflow-y: auto;
            text-align: left;
            box-sizing: border-box;
            line-height: 1.2;
            font-family: monospace;
            width: 394px; /* ゲームボードの幅に合わせる */
            height: 90px;  /* 高さを調整 */
            color: #cccccc;
        }
        #infoMessageBox {
            border-color: #42a5f5; /* 枠線を青色に変更 */
        }
        .modal {
            display: none; 
            position: fixed; 
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #2a2a2a;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #555;
            width: 90%;
            max-width: 400px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .modal-content h2 {
            margin-top: 0;
            color: #81c784;
            text-align: center;
        }
        #modalPatternSelect {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        #modalPatternPreview {
            display: grid;
            grid-template-columns: repeat(7, 25px);
            grid-template-rows: repeat(7, 25px);
            gap: 2px;
            margin: 10px auto 0;
            border: 1px solid #424242;
            padding: 3px;
            border-radius: 3px;
            background-color: #212121;
            width: fit-content;
        }
        .preview-square {
            width: 25px;
            height: 25px;
            background-color: #303030;
            border: 1px solid #616161;
            border-radius: 2px;
        }
        .preview-square.wall {
            background-color: #757575;
        }
        .enemy-indicator {
            width: 12px;
            height: 12px;
            background-color: #ef5350;
            border: 1px solid #c62828;
            border-radius: 2px;
        }
        #modalPatternSelect button {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            background-color: #424242;
            color: #eeeeee;
            border: none;
            transition: background-color 0.3s ease;
        }
        #modalPatternSelect button.selected {
            background-color: #81c784;
            color: #121212;
        }
        #modalEndlessButton, #modalEffectButton {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            transition: background-color 0.3s ease;
        }
        .modal-dual-section {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            width: 100%;
        }
        .modal-sub-section {
            text-align: center;
        }
        .modal-sub-section h3 {
            margin-bottom: 0.8rem;
        }
        #modalEndlessButton {
            background-color: #424242;
            color: #eeeeee;
        }
        #modalEndlessButton.active {
            background-color: #ffb74d;
            color: #121212;
        }
        #modalEffectButton.state-1 { background-color: #1ca123; color: #ffffff; }
        #modalEffectButton.state-2 { background-color: #9d7e03; color: #ffffff; }
        #modalEffectButton.state-3 { background-color: #e62f48; color: #ffffff; }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 1rem;
        }
        .modal-footer button {
            padding: 0.6rem 1.2rem;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            transition: background-color 0.3s ease;
        }
        #closeModalButton {
            background-color: #616161;
            color: #eeeeee;
        }
        #closeModalButton:hover {
            background-color: #757575;
        }
        #confirmSettingsButton {
            background-color: #42a5f5;
            color: #ffffff;
        }
        #confirmSettingsButton:hover {
            background-color: #1e88e5;
        }

        @keyframes new-ally-fade-in {
            0% { opacity: 0.5; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }

        .arrow {
            position: absolute;
            width: 0;
            height: 0;
            z-index: 3;
        }
        .arrow.up { border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 12px solid palegreen; top: -8px; }
        .arrow.down { border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 12px solid palegreen; bottom: -8px; }
        .arrow.left { border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-right: 12px solid palegreen; left: -8px; }
        .arrow.right { border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-left: 12px solid palegreen; right: -8px; }

        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            animation: particle-fade-out 0.7s ease-out forwards;
        }
        @keyframes particle-fade-out {
            0% {
                transform: translate(0, 0);
                opacity: 0.8;
            }
            100% {
                transform: translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }
        
        #scoreContainer {
            text-align: center;
            margin-bottom: 0.5rem;
        }

        #scoreDisplay {
            font-size: 1rem; 
            color: #ffeb3b; 
            font-family: 'Press Start 2P', cursive;
        }

        #highScoreDisplay {
            font-size: 0.8rem;
            color: #bdbdbd;
            font-family: 'Press Start 2P', cursive;
            margin-top: 4px;
        }
        
        #highScoreDisplay.new-high-score {
            animation: new-high-score-flash 0.5s 6;
        }
        
        @keyframes new-high-score-flash {
            0%, 100% { color: #ffeb3b; }
            50% { color: #121212; }
        }


        @media (max-width: 600px) {
            #gameBoard { grid-template-columns: repeat(7, 40px); grid-template-rows: repeat(7, 40px); }
            .square { width: 40px; height: 40px; font-size: 0.6rem; }
            h1 { font-size: 1.2rem; }
            #controlButton { font-size: 0.8rem; padding: 0.5rem; width: 10rem; }
            #gameOverPanel { padding: 0.5rem; font-size: 0.8rem; }
            #levelDisplay { font-size: 0.6rem; gap: 5px; }
            #autoButton, #speedButton, #autoStopButton { font-size: 0.7rem; padding: 0.5rem; }
            .game-controls button { font-size: 0.7rem; padding: 0.5rem; }
            #specialActionsArea { gap: 10px; }
            #specialActionsArea button {
                font-size: 0.6rem;
                padding: 0.4rem 0.8rem;
            }
            .counter-span { font-size: 0.7rem; }
            #infoMessageBox,
            #messageBox {
                width: 324px; /* モバイル表示でのゲームボード幅 */
            }
        }
    </style>
</head>
<body>
    <h1>EvoGame</h1>
    <div style="display: flex; gap: 5px; margin-bottom: 0.5rem;" class="game-controls">
        <button id="settingsButton">Setting</button>
        <button id="resetGameButton">Reset</button>
        <button id="finishButton">Finish</button>
    </div>

    <div id="scoreContainer">
        <div id="scoreDisplay">Score: <span id="scoreValue">0</span></div>
        <div id="highScoreDisplay">Hi-Score: <span id="highScoreValue">0</span></div>
    </div>


    <div id="gameBoard"></div>

    <div id="mainButtonContainer">
        <button id="controlButton">味方配置</button>
    </div>

    <div id="controlArea">
        <button id="autoButton">オート</button>
        <button id="autoStopButton">
            <div class="stop-cell"></div><div class="stop-cell"></div><div class="stop-cell"></div>
            <div class="stop-cell"></div><div class="stop-cell"></div><div class="stop-cell"></div>
            <div class="stop-cell"></div><div class="stop-cell"></div><div class="stop-cell"></div>
        </button>
        <button id="speedButton">Speed x1</button>
    </div>

    <div id="specialActionsArea">
        <div class="special-action">
            <button id="shuffleButton">Shuffle</button>
            <span id="shuffleCounter" class="counter-span">(0)</span>
        </div>
        <div class="special-action">
            <button id="downButton">Down</button>
            <span id="downCounter" class="counter-span">(0)</span>
        </div>
        <div class="special-action">
            <button id="bonusButton">Bonus</button>
            <span id="bonusCounter" class="counter-span">(0)</span>
        </div>
    </div>

    <div id="levelDisplay">
        <div>CurrentMaxLv: <span id="currentMaxLevel" class="level-value">0</span></div>
        <div>OverAllMaxLv: <span id="overallMaxLevel" class="level-value">0</span></div>
        <div>Turn: <span id="turnCounter" class="level-value">0</span></div>
    </div>

    <div id="infoMessageBox">
        <pre>【獲得ログ】</pre>
    </div>
    <div id="gameOverPanel">
        <h2>ゲームオーバー</h2>
        <p>味方が全滅しました。</p>
        <button id="closeGameOverButton">閉じる</button>
    </div>
    <div id="messageBox">
        <pre>【目的】
味方を合体させ、Lv.10,000に進化させよう！

【基本の流れ】
1. [味方配置]：新しい味方を盤上に追加します。
   - 味方の最大Lvが高いほど強い味方が現れます。
2. [敵移動]：敵が味方を追いかけ、捕まると消滅します。
3. [味方移動]：味方が移動し、合体するとLvが合算！

【その他のルール】
・味方が全滅するとゲームオーバーです。
・500ターンごとに新しい敵が出現します。
・条件を満たすと画面下の特殊能力が使えます。</pre>
    </div>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>ゲーム設定</h2>
            
            <div>
                <h3>ステージ選択</h3>
                <div id="modalPatternSelect">
                    <button data-pattern="1">パターン1</button>
                    <button data-pattern="2">パターン2</button>
                    <button data-pattern="3">パターン3</button>
                </div>
                <div id="modalPatternPreview"></div>
                </div>

            <div class="modal-dual-section">
                <div class="modal-sub-section">
                    <h3>モード</h3>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <button id="modalEndlessButton">Endless</button>
                        <span id="endlessModeDisplay" style="font-family: 'Press Start 2P', cursive; color: #ffeb3b; width: 60px; text-align: left;"></span>
                    </div>
                    </div>
                <div class="modal-sub-section">
                    <h3>難易度</h3>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <button id="modalEffectButton" class="state-1">E1</button>
                        <div id="enemyCountDisplay" style="display: flex; gap: 3px; height: 14px;"></div>
                    </div>
                    </div>
            </div>

            <div class="modal-footer">
                <button id="closeModalButton">戻る</button>
                <button id="confirmSettingsButton">決定</button>
            </div>
        </div>
    </div>
    
    <div id="particle-container"></div>

    <script>
        // DOM Elements
        const gameBoard = document.getElementById('gameBoard');
        const controlButton = document.getElementById('controlButton');
        const autoButton = document.getElementById('autoButton');
        const speedButton = document.getElementById('speedButton');
        const autoStopButton = document.getElementById('autoStopButton');
        const gameOverPanel = document.getElementById('gameOverPanel');
        const closeGameOverButton = document.getElementById('closeGameOverButton');
        const finishButton = document.getElementById('finishButton'); 
        const currentMaxLevelSpan = document.getElementById('currentMaxLevel');
        const overallMaxLevelSpan = document.getElementById('overallMaxLevel');
        const turnCounterSpan = document.getElementById('turnCounter');
        const scoreValueSpan = document.getElementById('scoreValue');
        const highScoreValueSpan = document.getElementById('highScoreValue');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const resetGameButton = document.getElementById('resetGameButton');
        const settingsButton = document.getElementById('settingsButton');
        const settingsModal = document.getElementById('settingsModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const confirmSettingsButton = document.getElementById('confirmSettingsButton');
        const modalPatternSelect = document.getElementById('modalPatternSelect');
        const modalEndlessButton = document.getElementById('modalEndlessButton');
        const modalEffectButton = document.getElementById('modalEffectButton');
        const modalPatternPreview = document.getElementById('modalPatternPreview');
        const endlessModeDisplay = document.getElementById('endlessModeDisplay');
        const enemyCountDisplay = document.getElementById('enemyCountDisplay');
        const shuffleButton = document.getElementById('shuffleButton');
        const downButton = document.getElementById('downButton');
        const bonusButton = document.getElementById('bonusButton');
        const shuffleCounterSpan = document.getElementById('shuffleCounter');
        const downCounterSpan = document.getElementById('downCounter');
        const bonusCounterSpan = document.getElementById('bonusCounter');
        const messagePre = document.getElementById('messageBox').querySelector('pre');
        const infoMessageBox = document.getElementById('infoMessageBox');
        const infoMessagePre = infoMessageBox.querySelector('pre');
        const particleContainer = document.getElementById('particle-container');

        // --- Game Constants ---
        const GAME_SETTINGS = {
            BOARD_SIZE: 7,
            CLEAR_LEVEL: 10000,
            ENDLESS_LEVEL_CAP: 10000,
            FINISH_BUTTON_ENABLE_TURN: 1000,
            
            ENEMY_ADDITION_INTERVAL_TURNS: 500,
            ENEMY_RANDOM_MOVE_MAX_DURATION: 15,
            ENEMY_SEEKING_MOVE_MAX_DURATION: 4,

            LEVEL_MILESTONE_DIVISOR: 10,

            SCORE_DIVISOR_DISAPPEARED: 30,
            SCORE_DIVISOR_NEW: 10,

            BONUS_MODE_MULTIPLIER_BASE: 11,
            BONUS_MODE_MULTIPLIER_SCALE: 0.1,

            SHUFFLE_COUNTER_TRIGGER_PLACEMENTS: 15,
            BONUS_COUNTER_TRIGGER_DEFEATS: 10,

            AUTO_STOP_ELIGIBLE_ALLY_LEVEL: 50,
            PARTICLE_DISTANCES: [30, 60],
        };

        const DIRECTIONS = [
            { row: -1, col: 0, dir: 'up' }, { row: 1, col: 0, dir: 'down' }, 
            { row: 0, col: -1, dir: 'left' }, { row: 0, col: 1, dir: 'right' }
        ];

        const BOARD_PATTERNS = [
            [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]],
            [[1, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 1, 1]],
            [[0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0]]
        ];
        
        const AUTO_SPEEDS = [
            { label: 'x1', interval: 1000 / 12 }, { label: 'x2', interval: 1000 / 24 }, { label: 'x4', interval: 1000 / 48 }
        ];
        const AUTO_STOP_MODES = ['unstop', 'around', 'adjacent'];

        // --- Game State ---
        let board = [];
        let allies = [];
        let enemies = [];
        let phase = 0;
        let turnCount = 0;
        let score = 0;
        let highScore = 0;
        let overallMaxLevel = 0;
        
        let gameOver = false;
        let gameClear = false;
        
        let autoMode = false;
        let autoIntervalId;
        
        let currentPattern = 0;
        let endlessMode = false;
        let effectState = 1;
        
        let bonusMode = false;
        let bonusMoveCounter = 0;

        let shuffleCounter = 0;
        let downCounter = 0;
        let bonusCounter = 0;
        let allyPlacementCount = 0;
        let allyDefeatCount = 0;
        let downTriggerLevel = 10;
        
        let currentSpeedIndex = 0;
        let currentAutoStopIndex = 0;

        let tempPattern = 0;
        let tempEndlessMode = false;
        let tempEffectState = 1;

        let newlyPlacedAllies = [];
        let evolutionCount = 0;

        // --- Game Initialization ---
        function initGame() {
            gameOver = false;
            gameClear = false;
            gameOverPanel.style.display = 'none';
            board = BOARD_PATTERNS[currentPattern].map(row => [...row]);
            allies = [];
            enemies = [];
            phase = 0;
            overallMaxLevel = 0;
            turnCount = 0;
            score = 0;
            allyPlacementCount = 0;
            allyDefeatCount = 0;
            evolutionCount = 0;
            bonusMoveCounter = 0;
            downTriggerLevel = 10;
            
            if(infoMessagePre) infoMessagePre.textContent = '【獲得ログ】';
            
            highScore = localStorage.getItem('evoGameHighScore') || 0;
            
            if (endlessMode) {
                finishButton.style.display = 'inline-block';
                finishButton.disabled = true;
            } else {
                finishButton.style.display = 'none';
            }
            
            controlButton.textContent = '味方配置';
            controlButton.disabled = false;
            autoButton.disabled = false;
            
            if (autoIntervalId) clearInterval(autoIntervalId);
            autoMode = false;
            autoButton.classList.remove('active');
            autoButton.textContent = 'オート';
            
            bonusMode = false;
            bonusButton.classList.remove('active');
            
            initCounters();
            updateAllDisplays();
            createBoard();
            placeInitialCharacters();
            updateBoard();
        }

        function initCounters() {
            shuffleCounter = 0;
            downCounter = 0;
            bonusCounter = 0;
            currentSpeedIndex = 0;
            currentAutoStopIndex = 0;
            autoStopButton.className = `state-${AUTO_STOP_MODES[currentAutoStopIndex]}`;
            speedButton.textContent = `Speed ${AUTO_SPEEDS[currentSpeedIndex].label}`;
        }
        
        // --- Core Game Loop ---
        function handleButtonClick() {
            if (gameOver || (gameClear && !endlessMode)) return;

            if (phase === 0 && bonusMode && bonusMoveCounter >= 5) {
                bonusMode = false;
                bonusButton.classList.remove('active');
                bonusMoveCounter = 0;
                updateCountersDisplay();
            }

            switch (phase) {
                case 0:
                    placeAlly();
                    allyPlacementCount++;
                    if (allyPlacementCount > 0 && allyPlacementCount % GAME_SETTINGS.SHUFFLE_COUNTER_TRIGGER_PLACEMENTS === 0) {
                        shuffleCounter++;
                        logInfoMessage(`Shuffle +1 (味方${GAME_SETTINGS.SHUFFLE_COUNTER_TRIGGER_PLACEMENTS}体配置)`);
                    }
                    phase = 1;
                    controlButton.textContent = '敵移動';
                    break;
                case 1:
                    moveEnemies();
                    prepareNextEnemyMoves();
                    phase = 2;
                    controlButton.textContent = '味方移動';
                    break;
                case 2:
                    moveAllies();
                    turnCount++;
                    checkTurnBasedEvents();
                    phase = 0;
                    controlButton.textContent = '味方配置';
                    break;
            }
            updateBoard();
            updateAllDisplays();
        }
        
        function checkTurnBasedEvents() {
            if (turnCount > 0 && turnCount % GAME_SETTINGS.ENEMY_ADDITION_INTERVAL_TURNS === 0) {
                addNewEnemyByTurn();
            }
            if (endlessMode && turnCount > GAME_SETTINGS.FINISH_BUTTON_ENABLE_TURN) {
                finishButton.disabled = false;
            }
        }
        
        // --- Character Actions: Ally ---
        function placeAlly() {
            const emptySquares = getAvailableSquares();
            const numAlliesToPlace = 1 + evolutionCount;
            const actualAlliesToPlace = Math.min(numAlliesToPlace, emptySquares.length);
            const deficit = numAlliesToPlace - actualAlliesToPlace;

            if (deficit > 0) {
                const sortedAllies = [...allies].sort((a, b) => a.level - b.level);
                for (let i = 0; i < deficit && i < sortedAllies.length; i++) {
                    const minLevelAlly = sortedAllies[i];
                    minLevelAlly.level *= 2;
                }
            }
            
            const justPlaced = [];
            for (let i = 0; i < actualAlliesToPlace; i++) {
                const randomIndex = Math.floor(Math.random() * emptySquares.length);
                const { row, col } = emptySquares.splice(randomIndex, 1)[0];
                const newAllyLevel = 1 + Math.floor(getCurrentMaxLevel() / GAME_SETTINGS.LEVEL_MILESTONE_DIVISOR);
                const newAlly = { row, col, level: newAllyLevel };
                allies.push(newAlly);
                justPlaced.push(newAlly);
            }
            newlyPlacedAllies = justPlaced;
            evolutionCount = 0;
            
            animatePlacement(newlyPlacedAllies, '#F5F5DC');
        }

        function moveAllies() {
            if (bonusMode) bonusMoveCounter++;

            const destinations = calculateAllyDestinations();
            const evolutionResult = processEvolutions(destinations);
            
            allies = evolutionResult.newAllies;
            evolutionCount += evolutionResult.evolutionsThisTurn;
            score += evolutionResult.scoreIncrease;
            
            checkGameClear();
        }

        function calculateAllyDestinations() {
            const destinations = {};
            allies.forEach(ally => {
                const possibleMoves = [{ row: ally.row, col: ally.col }];
                for (const dir of DIRECTIONS) {
                    const newRow = ally.row + dir.row, newCol = ally.col + dir.col;
                    if (newRow >= 0 && newRow < GAME_SETTINGS.BOARD_SIZE && newCol >= 0 && newCol < GAME_SETTINGS.BOARD_SIZE && board[newRow][newCol] !== 1 && !enemies.some(e => newRow === e.row && newCol === e.col)) {
                        possibleMoves.push({ row: newRow, col: newCol });
                    }
                }
                const { row, col } = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                const key = `${row}-${col}`;
                if (!destinations[key]) destinations[key] = [];
                destinations[key].push(ally);
            });
            return destinations;
        }

        function processEvolutions(destinations) {
            const newAllies = [];
            let evolutionsThisTurn = 0;
            let sumOfDisappearedLevels = 0;
            let sumOfNewLevels = 0;

            for (const key in destinations) {
                const group = destinations[key];
                const [destRow, destCol] = key.split('-').map(Number);

                if (group.length > 1) { 
                    const sumOfLevels = group.reduce((sum, ally) => sum + ally.level, 0);
                    const initialMaxLevel = group.reduce((max, ally) => Math.max(max, ally.level), 0);
                    let finalLevel;

                    if (bonusMode) {
                        const multiplier = (GAME_SETTINGS.BONUS_MODE_MULTIPLIER_BASE + group.length) * GAME_SETTINGS.BONUS_MODE_MULTIPLIER_SCALE;
                        finalLevel = Math.ceil(sumOfLevels * multiplier);
                    } else {
                        finalLevel = sumOfLevels;
                    }

                    if ((initialMaxLevel < GAME_SETTINGS.CLEAR_LEVEL && finalLevel >= GAME_SETTINGS.CLEAR_LEVEL) || (initialMaxLevel >= GAME_SETTINGS.CLEAR_LEVEL)) {
                        evolutionsThisTurn++;
                    }
                    
                    const maxLevelCap = endlessMode ? GAME_SETTINGS.ENDLESS_LEVEL_CAP : GAME_SETTINGS.CLEAR_LEVEL;
                    finalLevel = Math.min(finalLevel, maxLevelCap);
                    
                    sumOfDisappearedLevels += sumOfLevels;
                    sumOfNewLevels += finalLevel;
                    newAllies.push({ row: destRow, col: destCol, level: finalLevel });
                    
                    const isMaxLevelEvo = initialMaxLevel === getCurrentMaxLevel() && getCurrentMaxLevel() > 1;
                    let particleColor = bonusMode ? '#FFA500' : (isMaxLevelEvo ? '#42a5f5' : '#80DEEA');
                    animatePlacement([{row: destRow, col: destCol}], particleColor);

                } else { 
                    newAllies.push({ row: destRow, col: destCol, level: group[0].level });
                }
            }
            
            const scoreIncrease = Math.floor(sumOfDisappearedLevels / GAME_SETTINGS.SCORE_DIVISOR_DISAPPEARED) + Math.floor(sumOfNewLevels / GAME_SETTINGS.SCORE_DIVISOR_NEW) + (Object.keys(destinations).length < allies.length ? 1 : 0);
            
            return { newAllies, evolutionsThisTurn, scoreIncrease };
        }
        
        // --- Character Actions: Enemy ---
        function moveEnemies() {
            enemies.forEach(enemy => {
                if (enemy.nextMove) {
                    enemy.row = enemy.nextMove.row;
                    enemy.col = enemy.nextMove.col;
                    const targetAllyIndex = allies.findIndex(ally => ally.row === enemy.row && ally.col === enemy.col);
                    if (targetAllyIndex !== -1) {
                        const removedAlly = allies.splice(targetAllyIndex, 1)[0];
                        animatePlacement([removedAlly], '#ef5350');
                        
                        allyDefeatCount++;
                        if (allyDefeatCount > 0 && allyDefeatCount % GAME_SETTINGS.BONUS_COUNTER_TRIGGER_DEFEATS === 0) {
                            bonusCounter++;
                            logInfoMessage(`Bonus +1 (味方${GAME_SETTINGS.BONUS_COUNTER_TRIGGER_DEFEATS}体消滅)`);
                        }
                    }
                }
            });
            checkGameOver();
        }
        
        function prepareNextEnemyMoves() {
            const intendedMoves = new Set();
            enemies.forEach(enemy => {
                decideNextEnemyMove(enemy, enemies, intendedMoves);
                if (enemy.nextMove) {
                    intendedMoves.add(`${enemy.nextMove.row}-${enemy.nextMove.col}`);
                }
            });
        }
        
        function decideNextEnemyMove(enemy, allEnemies, intendedMoves) {
            enemy.moveCounter--;

            if (enemy.moveCounter <= 0) {
                enemy.movementMode = (enemy.movementMode === 'random') ? 'seeking' : 'random';
                enemy.moveCounter = (enemy.movementMode === 'random') 
                    ? Math.floor(Math.random() * GAME_SETTINGS.ENEMY_RANDOM_MOVE_MAX_DURATION) + 1
                    : Math.floor(Math.random() * GAME_SETTINGS.ENEMY_SEEKING_MOVE_MAX_DURATION) + 1;
            }

            let possibleMoves = [];
            let possibleDirections = [];
            
            if (enemy.movementMode === 'seeking' && allies.length > 0) {
                const targetAlly = allies.reduce((max, ally) => ally.level > max.level ? ally : max, allies[0]);
                const desiredDirections = [];
                const dy = targetAlly.row - enemy.row;
                const dx = targetAlly.col - enemy.col;

                if (dy > 0) desiredDirections.push(DIRECTIONS.find(d => d.dir === 'down'));
                if (dy < 0) desiredDirections.push(DIRECTIONS.find(d => d.dir === 'up'));
                if (dx > 0) desiredDirections.push(DIRECTIONS.find(d => d.dir === 'right'));
                if (dx < 0) desiredDirections.push(DIRECTIONS.find(d => d.dir === 'left'));
                
                for (const dir of desiredDirections) {
                    if (!dir) continue;
                    addPossibleMove(enemy.row + dir.row, enemy.col + dir.col, dir.dir, intendedMoves, possibleMoves, possibleDirections);
                }
            }

            if (possibleMoves.length === 0) {
                const shuffledDirections = [...DIRECTIONS].sort(() => 0.5 - Math.random());
                for (const dir of shuffledDirections) {
                    addPossibleMove(enemy.row + dir.row, enemy.col + dir.col, dir.dir, intendedMoves, possibleMoves, possibleDirections);
                }
            }

            if (possibleMoves.length > 0) {
                const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                enemy.nextMove = possibleMoves[randomIndex];
                enemy.nextDirection = possibleDirections[randomIndex];
            } else {
                enemy.nextMove = { row: enemy.row, col: enemy.col };
                enemy.nextDirection = null;
            }
        }
        
        function addPossibleMove(row, col, dir, intendedMoves, possibleMoves, possibleDirections) {
            const moveKey = `${row}-${col}`;
            if (row >= 0 && row < GAME_SETTINGS.BOARD_SIZE && col >= 0 && col < GAME_SETTINGS.BOARD_SIZE && board[row][col] !== 1 && !intendedMoves.has(moveKey)) {
                possibleMoves.push({ row, col });
                possibleDirections.push(dir);
            }
        }

        function addNewEnemyByTurn() {
            const availableSquares = getAvailableSquares();
            let newEnemyPosition;

            if (availableSquares.length > 0) {
                newEnemyPosition = availableSquares[Math.floor(Math.random() * availableSquares.length)];
            } else if (allies.length > 0) {
                const targetAllyIndex = Math.floor(Math.random() * allies.length);
                const targetAlly = allies[targetAllyIndex];
                newEnemyPosition = { row: targetAlly.row, col: targetAlly.col };
                animatePlacement([targetAlly], '#42a5f5');
                allies.splice(targetAllyIndex, 1);
            } else {
                return;
            }

            const newEnemy = {
                row: newEnemyPosition.row, col: newEnemyPosition.col, nextMove: null, nextDirection: null,
                movementMode: 'random', moveCounter: Math.floor(Math.random() * GAME_SETTINGS.ENEMY_RANDOM_MOVE_MAX_DURATION) + 1
            };
            enemies.push(newEnemy);

            const intendedMoves = new Set(enemies.map(e => e.nextMove ? `${e.nextMove.row}-${e.nextMove.col}` : '').filter(Boolean));
            decideNextEnemyMove(newEnemy, enemies, intendedMoves);

            animatePlacement([newEnemy], '#ef5350');
            // ▼▼▼ この行を logInfoMessage に変更 ▼▼▼
            logInfoMessage(`Turn ${turnCount}: A new enemy has appeared!`);
        }

        // --- Game State Checks ---
        function checkGameOver() {
            if (allies.length === 0) {
                endGame(false, "ゲームオーバー", "味方が全滅しました。");
            }
        }
        
        function checkGameClear() {
            if (allies.some(ally => ally.level >= GAME_SETTINGS.CLEAR_LEVEL) && !endlessMode) {
                endGame(true, "ゲームクリア！", `おめでとうございます！レベル${GAME_SETTINGS.CLEAR_LEVEL}に到達しました。`);
            }
        }
        
        function endGame(isClear, title, message) {
            if (isClear) gameClear = true; else gameOver = true;
            
            if (autoIntervalId) clearInterval(autoIntervalId);
            autoMode = false;
            autoButton.classList.remove('active');
            
            controlButton.disabled = true;
            autoButton.disabled = true;
            finishButton.disabled = true;
            [shuffleButton, downButton, bonusButton].forEach(btn => btn.disabled = true);
            
            checkHighScore();
            gameOverPanel.querySelector('h2').textContent = title;
            gameOverPanel.querySelector('p').textContent = message;
            gameOverPanel.style.display = 'block';
        }

        // --- UI & Display Updates ---
        function updateAllDisplays() {
            updateLevelDisplay();
            updateCountersDisplay();
            turnCounterSpan.textContent = turnCount;
            scoreValueSpan.textContent = score;
            highScoreValueSpan.textContent = highScore;
        }

        function updateBoard() {
            const maxLevel = getCurrentMaxLevel();
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    const square = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
                    square.className = 'square';
                    square.innerHTML = '';
                    if (board[i][j] === 1) square.classList.add('wall');
                    else square.classList.add('empty');
                }
            }
            enemies.forEach(enemy => {
                const square = document.querySelector(`[data-row="${enemy.row}"][data-col="${enemy.col}"]`);
                if (!square) return;
                const container = document.createElement('div');
                container.className = 'enemy-container';
                const enemyDiv = document.createElement('div');
                enemyDiv.className = 'enemy';
                enemyDiv.textContent = 'E';
                container.appendChild(enemyDiv);
                if (enemy.nextDirection) {
                    const arrow = document.createElement('div');
                    arrow.className = `arrow ${enemy.nextDirection}`;
                    container.appendChild(arrow);
                }
                square.appendChild(container);
            });
            allies.forEach(ally => {
                const square = document.querySelector(`[data-row="${ally.row}"][data-col="${ally.col}"]`);
                if (!square) return;
                square.classList.add('ally');
                if (newlyPlacedAllies.includes(ally)) square.classList.add('new-ally');
                square.textContent = ally.level >= 100 ? `Lv\n${ally.level}` : `Lv${ally.level}`;
                if (ally.level >= 2 && ally.level === maxLevel) square.classList.add('top-right-indicator', 'max-level-ally');
            });
            newlyPlacedAllies = [];
        }

        function updateLevelDisplay() {
            const currentMax = getCurrentMaxLevel();
            const oldOverallMax = overallMaxLevel;
            overallMaxLevel = Math.max(overallMaxLevel, currentMax);

            const getColorForLevel = (level) => {
                if (level >= GAME_SETTINGS.CLEAR_LEVEL) return '#42a5f5'; 
                if (level >= GAME_SETTINGS.CLEAR_LEVEL / 2) return '#ef5350'; 
                if (level >= GAME_SETTINGS.CLEAR_LEVEL / 10) return '#81c784'; 
                return '#ffffff';
            };

            currentMaxLevelSpan.textContent = currentMax;
            currentMaxLevelSpan.style.color = getColorForLevel(currentMax);
            overallMaxLevelSpan.textContent = overallMaxLevel;
            overallMaxLevelSpan.style.color = getColorForLevel(overallMaxLevel);
            
            while (overallMaxLevel >= downTriggerLevel) {
                downCounter++;
                logInfoMessage(`Down +1 (Lv${downTriggerLevel}達成)`);
                downTriggerLevel *= 2;
            }
        }
        
        function updateCountersDisplay() {
            shuffleCounterSpan.textContent = `(${shuffleCounter})`;
            shuffleButton.disabled = shuffleCounter <= 0;
            downCounterSpan.textContent = `(${downCounter})`;
            downButton.disabled = downCounter <= 0;
            bonusCounterSpan.textContent = `(${bonusCounter})`;
            bonusButton.disabled = bonusCounter <= 0 && !bonusButton.classList.contains('active');
        }

        function checkHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('evoGameHighScore', highScore);
                highScoreDisplay.classList.add('new-high-score');
                setTimeout(() => highScoreDisplay.classList.remove('new-high-score'), 3000);
            }
        }

        // --- Helpers & Utilities ---
        function getAvailableSquares() {
            const squares = [];
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    const isOccupied = enemies.some(e => e.row === i && e.col === j) || allies.some(a => a.row === i && a.col === j);
                    if (board[i][j] === 0 && !isOccupied) {
                        squares.push({ row: i, col: j });
                    }
                }
            }
            return squares;
        }

        function getCurrentMaxLevel() {
            return allies.length > 0 ? Math.max(...allies.map(ally => ally.level)) : 0;
        }

        function placeCharacter(type, initialLevel = 0) {
            const availableSquares = getAvailableSquares();
            if (availableSquares.length > 0) {
                const { row, col } = availableSquares[Math.floor(Math.random() * availableSquares.length)];
                return type === 0 ? { 
                    row, col, nextMove: null, nextDirection: null, movementMode: 'random',
                    moveCounter: Math.floor(Math.random() * GAME_SETTINGS.ENEMY_RANDOM_MOVE_MAX_DURATION) + 1
                } : { row, col, level: initialLevel };
            }
            return null;
        }
        
        function placeInitialCharacters() {
            for (let i = 0; i < effectState; i++) {
                const newEnemy = placeCharacter(0);
                if (newEnemy) enemies.push(newEnemy);
            }
            prepareNextEnemyMoves();
            const firstAlly = placeCharacter(1, 1);
            if (firstAlly) {
                allies.push(firstAlly);
                newlyPlacedAllies = [firstAlly];
                animatePlacement(newlyPlacedAllies, '#F5F5DC');
            }
        }
        
        function logMessage(message) {
            let currentMessages = messagePre.textContent.split('\n');
            currentMessages.unshift(message);
            if (currentMessages.length > 10) currentMessages.pop();
            messagePre.textContent = currentMessages.join('\n');
        }

        function logInfoMessage(message) {
            if (!infoMessagePre) return;
            let currentMessages = infoMessagePre.textContent.split('\n');
            const title = currentMessages.shift();
            currentMessages = currentMessages.filter(msg => msg.trim() !== '');
            currentMessages.unshift(`> ${message}`);
            // ▼▼▼ 行数制限を5から4に変更 ▼▼▼
            if (currentMessages.length > 4) currentMessages.pop();
            infoMessagePre.textContent = [title, ...currentMessages].join('\n');
        }

        // --- Animations & Effects ---
        function createParticles(x, y, color) {
            if (!particleContainer) return;
            GAME_SETTINGS.PARTICLE_DISTANCES.forEach(distance => {
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI / 4;
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    particle.style.backgroundColor = color;
                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                    particleContainer.appendChild(particle);
                    particle.addEventListener('animationend', () => particle.remove());
                }
            });
        }
        
        function animatePlacement(units, color) {
            setTimeout(() => {
                units.forEach(unit => {
                    const square = document.querySelector(`[data-row="${unit.row}"][data-col="${unit.col}"]`);
                    if (square) {
                        const rect = square.getBoundingClientRect();
                        createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, color);
                    }
                });
            }, 10);
        }

        // --- Board & Special Actions ---
        function createBoard() {
            gameBoard.innerHTML = '';
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = i;
                    square.dataset.col = j;
                    gameBoard.appendChild(square);
                }
            }
        }
        
        function shufflePositions() {
            if (gameOver || gameClear) return;
            const allUnits = [...allies, ...enemies];
            const allPositions = [];
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    if (board[i][j] !== 1) allPositions.push({ row: i, col: j });
                }
            }
            if (allUnits.length > allPositions.length) return;

            for (let i = allPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
            }
            
            allUnits.forEach((unit, index) => {
                unit.row = allPositions[index].row;
                unit.col = allPositions[index].col;
            });

            prepareNextEnemyMoves();
            updateBoard();
        }

        function consolidateAlliesVertically() {
            if (gameOver || (gameClear && !endlessMode)) return;

            const newAllies = [];
            for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                const alliesInCol = allies.filter(a => a.col === j);
                if (alliesInCol.length > 0 && !enemies.some(e => e.col === j)) {
                    const totalLevel = alliesInCol.reduce((sum, ally) => sum + ally.level, 0);
                    let targetRow = -1;
                    for (let i = GAME_SETTINGS.BOARD_SIZE - 1; i >= 0; i--) {
                        if (board[i][j] !== 1) {
                            targetRow = i;
                            break;
                        }
                    }
                    if (targetRow !== -1) newAllies.push({ row: targetRow, col: j, level: totalLevel });
                }
            }
            allies = newAllies;
            updateBoard();
            updateLevelDisplay();
        }
        
        // --- Event Listeners ---
        function setupEventListeners() {
            controlButton.addEventListener('click', handleButtonClick);
            autoButton.addEventListener('click', toggleAutoMode);
            speedButton.addEventListener('click', () => {
                currentSpeedIndex = (currentSpeedIndex + 1) % AUTO_SPEEDS.length;
                speedButton.textContent = `Speed ${AUTO_SPEEDS[currentSpeedIndex].label}`;
                if (autoMode) toggleAutoMode(), toggleAutoMode();
            });
            autoStopButton.addEventListener('click', () => {
                currentAutoStopIndex = (currentAutoStopIndex + 1) % AUTO_STOP_MODES.length;
                autoStopButton.className = `state-${AUTO_STOP_MODES[currentAutoStopIndex]}`;
            });
            shuffleButton.addEventListener('click', () => {
                if (shuffleCounter > 0) { shuffleCounter--; updateCountersDisplay(); shufflePositions(); }
            });
            downButton.addEventListener('click', () => {
                if (downCounter > 0) { downCounter--; updateCountersDisplay(); consolidateAlliesVertically(); }
            });
            bonusButton.addEventListener('click', () => {
                if (!bonusMode) { 
                    if (bonusCounter > 0) { bonusCounter--; bonusMode = true; bonusButton.classList.add('active'); bonusMoveCounter = 0; }
                } else { bonusMode = false; bonusButton.classList.remove('active'); }
                updateCountersDisplay();
            });
            finishButton.addEventListener('click', () => {
                if(gameOver || gameClear) return;
                endGame(true, "ゲーム終了", `ターン ${turnCount} で終了しました。お疲れ様でした！`);
            });
            resetGameButton.addEventListener('click', () => {
                logInfoMessage("ゲームをリセットしました。");
                initGame();
            });
            closeGameOverButton.addEventListener('click', () => { gameOverPanel.style.display = 'none'; });
            settingsButton.addEventListener('click', () => {
                tempPattern = currentPattern; tempEndlessMode = endlessMode; tempEffectState = effectState;
                updateModalUI(); updatePatternPreview(tempPattern); settingsModal.style.display = 'block';
            });
            closeModalButton.addEventListener('click', () => { settingsModal.style.display = 'none'; });
            confirmSettingsButton.addEventListener('click', () => {
                currentPattern = tempPattern; endlessMode = tempEndlessMode; effectState = tempEffectState;
                initGame(); settingsModal.style.display = 'none';
            });
            modalPatternSelect.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (button) { tempPattern = parseInt(button.dataset.pattern) - 1; updateModalUI(); updatePatternPreview(tempPattern); }
            });
            modalEndlessButton.addEventListener('click', () => { tempEndlessMode = !tempEndlessMode; updateModalUI(); });
            modalEffectButton.addEventListener('click', () => { tempEffectState = (tempEffectState % 3) + 1; updateModalUI(); });
        }
        
        function toggleAutoMode() {
            autoMode = !autoMode;
            autoButton.classList.toggle('active', autoMode);
            if (autoMode) {
                const autoPlay = () => {
                    if (checkAutoStopCondition()) {
                        toggleAutoMode(); return;
                    }
                    handleButtonClick();
                };
                autoIntervalId = setInterval(autoPlay, AUTO_SPEEDS[currentSpeedIndex].interval);
            } else {
                clearInterval(autoIntervalId);
            }
        }
        
        function checkAutoStopCondition() {
            const mode = AUTO_STOP_MODES[currentAutoStopIndex];
            if (mode === 'unstop' || allies.length === 0) return false;
            const eligibleAllies = allies.filter(ally => ally.level >= GAME_SETTINGS.AUTO_STOP_ELIGIBLE_ALLY_LEVEL);
            if (eligibleAllies.length === 0) return false;

            const maxLevelAlly = eligibleAllies.reduce((prev, current) => (prev.level > current.level) ? prev : current);
            const checks = (mode === 'around') 
                ? [{r: -1, c: -1}, {r: -1, c: 0}, {r: -1, c: 1}, {r: 0, c: -1}, {r: 0, c: 1}, {r: 1, c: -1}, {r: 1, c: 0}, {r: 1, c: 1}]
                : [{r: -1, c: 0}, {r: 0, c: -1}, {r: 0, c: 1}, {r: 1, c: 0}];

            return checks.some(check => enemies.some(e => e.row === maxLevelAlly.row + check.r && e.col === maxLevelAlly.col + check.c));
        }
        
        // --- Settings Modal ---
        function createPatternPreview() {
            modalPatternPreview.innerHTML = '';
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    const square = document.createElement('div');
                    square.className = 'preview-square';
                    square.dataset.row = i; square.dataset.col = j;
                    modalPatternPreview.appendChild(square);
                }
            }
        }

        function updatePatternPreview(patternIndex) {
            const pattern = BOARD_PATTERNS[patternIndex];
            for (let i = 0; i < GAME_SETTINGS.BOARD_SIZE; i++) {
                for (let j = 0; j < GAME_SETTINGS.BOARD_SIZE; j++) {
                    const square = modalPatternPreview.querySelector(`[data-row="${i}"][data-col="${j}"]`);
                    if (square) square.classList.toggle('wall', pattern[i][j] === 1);
                }
            }
        }

        function updateModalUI() {
            modalPatternSelect.querySelectorAll('button').forEach(btn => btn.classList.toggle('selected', parseInt(btn.dataset.pattern) - 1 === tempPattern));
            modalEndlessButton.classList.toggle('active', tempEndlessMode);
            endlessModeDisplay.textContent = tempEndlessMode ? 'infinity' : String(GAME_SETTINGS.ENDLESS_LEVEL_CAP);
            const textMap = { 1: 'E1', 2: 'E2', 3: 'E3' };
            modalEffectButton.textContent = textMap[tempEffectState];
            modalEffectButton.className = `state-${tempEffectState}`;
            modalEffectButton.id = 'modalEffectButton';
            enemyCountDisplay.innerHTML = '';
            for (let i = 0; i < tempEffectState; i++) {
                const indicator = document.createElement('div');
                indicator.className = 'enemy-indicator';
                enemyCountDisplay.appendChild(indicator);
            }
        }
        
        // --- Entry Point ---
        setupEventListeners();
        createPatternPreview();
        initGame();
    </script>
</body>
</html>
